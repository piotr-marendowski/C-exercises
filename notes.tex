\documentclass[12pt, openany]{book}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{listings}                       % code 
\usepackage{lstautogobble}                  % segments
\usepackage{array}                          % tables
\usepackage{multirow}                       % tables multirows
\usepackage[table]{xcolor}                  % tables colors

% set code segment's parameters
\lstset{language=C,
    basicstyle=\small\ttfamily,
    stringstyle=\ttfamily,
    showstringspaces=false,
    autogobble=true
}

\newcommand\tab[1][20px]{\hspace*{#1}}      % tabs 20px
\setlength{\parindent}{0pt}                 % no tabs at start of the paragraphs

\title{My notes from K.N. King's "C Programming A Modern Approach" 2nd version}
\author{Piotr Marendowski}
\date{March 2023}

\begin{document}
    % PAGE 1
    \maketitle

    % PAGE 2
    \chapter{Note}
    In this material I will go over everything from book,
    trying to summarize every note-worthy subject. I will do
    it, while learning Latex, so good luck to me.

    % PAGE 3
    \tableofcontents

    % PAGE 4
    \chapter{C Fundamentals}
    
    \section{Steps of Executing a C Program}
    Automated proccess:
    \begin{enumerate}
        \item\textbf{Preprocessing} - Preprocessor is executing directives
        (they begin with \#).
        \item\textbf{Compiling} - Compiler translates program into machine
        instructions (object code).
        \item\textbf{Linking} - Linker combines object code and code needed
        for execution of the program.
    \end{enumerate}

    \section{The Genereral Form of a Simple Program}
    Simple C programs have this form:

    \bigskip
    \textit{directives}
    \smallskip

    \small\texttt{int main(void)} \\
    \small\texttt{\{} \\
    \tab\textit{statements} \\
    \small\texttt{\}}
    \bigskip

    \textbf{Directives} - Begin with '\#' symbol, they state what headers
    include to program.

    % PAGE 5
    \textbf{Functions} - They are segments of code that take arguments, and
    returns (or not) a value. Only \texttt{main} function is required.

    \textbf{Statements} - Commands to execute, mostly end with semicolon.

    \bigskip
    \textbf{String literal} - Series of characters enclosed in double quotation marks,
    e.g. \texttt{"Hello world!"}.

    \textbf{New-line character} - \texttt{\textbackslash n} is an escape sequence, which
    advances to the next line of output.

    \textbf{Comments} - Are ommited in program execution, can be used to comment single line
    e.g. \texttt{/* Comment */}, or block of lines. From C99 we can use one line comments
    e.g. \texttt{// Comment}.

    \section{Variables and Assigments}

    \textbf{Variable} - Place to store calculation's output, for using in future.
    Variable's characteristics:
    \begin{itemize}
        \item 
        \textbf{Types} - For now, there are two types of variables:
        \begin{itemize}
            \item \texttt{int} - Integer types, can store quite big whole number, but
            that depends on your computer's architecture.
            \item \texttt{float} - Can store bigger numbers, as well as digits after
            decimal point.
        \end{itemize}

        \item 
        \textbf{Declarations} - To use a variable, we first need to declare it. It
        means that we need to specify variable's type, and name. We can chain declarations
        with the same type e.g. \texttt{int i, sum, x;}. In C99 they can now be declared
        after statements, not like in C89.
        
        \item
        \textbf{Assignment} - We assign value to a variable. Variable is on the left
        side, while value, expression, formula etc. is on the right side. To assign
        something to a variable, we first need to declare it. Examples:
        \begin{lstlisting}
        int i;
        float f;
        i = 1;
        f = 1.5;
        \end{lstlisting}
    \end{itemize}

    \subsection*{Initialization}
    At the default most variables are uninitialized, which means that they have some
    random - garbage value assigned to them, if we didn't. In declaration we can assign
    value to a variable, making it an \textbf{initializer}, e.g. \texttt{int i = 0;}.

    % PAGE 6
    \section{Reading Input}
    For reading input we need to use \texttt{scanf} function, which needs a format
    string and value to read, e.g. \texttt{scanf("\%d", \&i);}.

    \section{Defining Names for Constants}
    To define a constant, we need to use a \textbf{macro definition}, which is
    interpreted by the preprocessor e.g. \texttt{\#define WIDTH 20}.

    \section{Identifiers}
    Names in C are called \textbf{identifiers}. They can begin with the lower-case or
    upper-case letters or underscores e.g. \texttt{times10  my\_var  \_done}. They
    cannot begin with a number e.g. \texttt{10times}. They cannot contain minus signs
    e.g. \texttt{my-var}.

    \subsection*{Keywords}
    There are number of keywords, which are prohibited from using as identifiers.

    \section{Layout of the C Program}
    We can slice C statements into \textbf{tokens}:
    \begin{lstlisting}
    printf   (   "Height:   %d\n"   ,   height   )   ;
      1      2      3         4     5     6      7   8
    \end{lstlisting}
    Tokens 1 and 2 are identifiers, token 3 is a string literal and tokens 2, 4, 6,
     and 7 are punctuation. \\
    In most cases we can put many spaces between them. But we cannot put spaces within
    tokens e.g. \texttt{fl oat f;}. 

    % PAGE 7
    \chapter{Formatted Input/Output}

    \section{The printf Function}
    Needs a format string and arguments to insert there. There is no limit to these
    arguments. Format string could have conversion specifications, which are supplied by
    its arguments, to insert into format string e.g. \texttt{printf("Value: \%d", i);}
    where \texttt{\%d} is a conversion specification and \texttt{i} is a value to be
    supplied to the format string.

    \section{Conversion specifications}
    Outside of letter(s) specifying which type to covert to, they consist of the \textbf{Minimal
    Field Width (m)} and \textbf{Precision (p)}. They have the form of: \texttt{\%m.pX}.

    \subsection*{Minimal field width}
    Specifies the minimum number of characters to print. If the number of characters
    to print is less than specified, the number is right justified with spaces added. If the number of
    characters is greater than specified it will automatically expand to display all of characters.

    \subsection*{Precision}
    Depends on the type to be displayed, reference the book for more detailed preview. 
    \newpage

    % PAGE 8
    Conversion specifications:
    \begin{itemize}
        \item \texttt{d} - Displays an integer in a decimal (base 10) form. \textit{p} indicates
        the minimum number of digits to display.
        \item \texttt{e} - Displays a floating-point number in exponential format. \textit{p}
        indicates the number of digits after the decimal point.
        \item \texttt{f} - Displays a floating-point number without an exponent. \textit{p} has
        the same meaning as previous.
        \item \texttt{g} - Displays a floating-point number in exponential format or
        fixed (without an exponent). \textit{p} indicates the maximum number of
        significant digits to be displayed. It depends on the size of the number.
    \end{itemize}

    \subsection*{Escape sequences}
    They are characters, that would introduce problems in compilation or have some action
    to do e.g. insert new line into output. Few of them are:
    \begin{itemize}
        \item \texttt{\textbackslash a} - alert (bell),
        \item \texttt{\textbackslash b} - backspace,
        \item \texttt{\textbackslash n} - new line,
        \item \texttt{\textbackslash t} - tab,
        \item \texttt{\textbackslash "} - qoute character,
        \item \texttt{\textbackslash\textbackslash} - slash character.
    \end{itemize}

    \section{The scanf Function}
    This funcion handles input from stdin stream (keyboard),  have a format string
    and may contain conversion specifications. The scanf call may look like that:
    \texttt{scanf("\%d", \&i);}. Scanf when reading an input ignores the white-space
    characters. It only matches input to the provided variables. If a reading error
    occurres, scanf will return immediately, ignoring the rest of the format string.
    It doesn't read the new-line character at the end of the input. If character
    cannot be read, function puts it back for the next variable and adds it to that.

    % PAGE 9
    \subsection*{Ordinary Characters in Format Strings}
    We can put a white-space characters into the format string, then scanf will read
    any number of white-space characters and discard them. When it encounters a
    non-white-space character it is trying to match it with an inputted character.
    If it fails, it returns.

    % PAGE 10
    \chapter{Expressions}

    \section{Arithmetic operators}
    \begin{tabular}{ |c|c|c| } 
        \hline
        \cellcolor{lightgray}Unary & \multicolumn{2}{|c|}{\cellcolor{lightgray}Binary} \\
        \hline
        & \cellcolor{lightgray}Additive & \cellcolor{lightgray}Multiplicative \\
        \cline{2-3}
        {}{}{\shortstack{+ unary plus \\ - unary minus}} & + addition & * multiplication \\ 
         & - subtraction & / division \\ 
         & & \% reminder \\
        \hline
    \end{tabular}

    \subsection*{Operator Precendence and Associativity}
    \textbf{Operator precendece} is in what order C calculates expressions. The arithmetic
    operators have the following relative precendence: \\
    \tab Highest: + - (unary) \\
    \tab\tab\tab \ * \ / \ \% \\    % single backslashes are spaces
    \tab Lowest: \ + - (binary)

    \bigskip
    \textbf{Associativity} decides in what order operators with the same precendece are
    calculated. The binary operators are all left associative, whilst the unary operators
    are all right associative.

    \section{Assignment Operators}
    Are used to store a computed value of the expression.

    % PAGE 11
    \subsection*{Simple Assignment}
    Evaluates an expression, which then assigns into the variable, expression can be a
    \textit{constant} (always has the same value). If they don't have the same type, the
    value of an expression is converted to the type of the variable. Assignments can be
    chained together e.g. \texttt{i = j = k = 0;}. The \texttt{=} operator is right
    associative. 

    \subsection*{Lvalues}
    Assignment operator requires that on its left side can only be a variable, not an
    expression e.g. \texttt{i + j = 0;} is wrong.

    \subsection*{Compound Assignment}
    We can shorten statements e.g. \texttt{i += 2;} is equivalent to
    \texttt{i = i + 2;}. It works with the other operators including the following:
    \texttt{-= *= /= \%=}, they all work in the same way and are right associative.


\end{document}